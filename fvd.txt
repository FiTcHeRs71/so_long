Synthèse du Projet "So Long"

Résumé Exécutif

Le projet "So Long" constitue une initiation fondamentale à la programmation graphique en C, utilisant la bibliothèque propriétaire MiniLibX (MLX). L'objectif est de développer un jeu 2D simple où le joueur doit collecter tous les objets sur une carte avant de pouvoir atteindre la sortie. Ce document de synthèse consolide les concepts clés, les exigences techniques et les méthodologies extraites des guides fournis. Les défis majeurs du projet résident dans la validation rigoureuse des cartes (.ber), incluant la vérification d'un chemin valide via des algorithmes comme le Flood Fill, et une gestion méticuleuse de la mémoire pour éviter toute fuite. La MiniLibX, agissant comme une interface simplifiée pour le système X-Window, est au cœur du projet, requérant une compréhension de son cycle de vie, de la gestion des événements par "hooks", et des techniques de rendu optimisées qui privilégient l'utilisation d'images comme tampons (buffers) plutôt que le dessin pixel par pixel directement à l'écran.


--------------------------------------------------------------------------------


1. Objectifs et Principes du Projet

Le projet "So Long" vise à développer les compétences en programmation graphique, en gestion de fenêtres, en traitement d'événements et en manipulation de textures. Il s'agit de la première incursion dans un environnement graphique après des projets en console.

1.1. Logique du Jeu

La mécanique de jeu est simple mais soumise à des règles strictes :

* Objectif : Le joueur doit ramasser tous les objets "collectibles" (marqués par un 'C') présents sur la carte. Une fois tous les collectibles récupérés, la sortie (marquée par un 'E') devient accessible. Le but final est d'atteindre cette sortie.
* Vue : Le jeu doit être présenté en 2D, soit en vue de dessus (top-down), soit en vue de profil (platformer).
* Déplacement : Le personnage principal se déplace dans les quatre directions (haut, bas, gauche, droite) à l'aide des touches W, A, S, D (ou Z, Q, S, D / flèches directionnelles).
* Contraintes : Le joueur ne peut pas traverser les murs (marqués par un '1').
* Interface : Le nombre total de mouvements effectués par le joueur doit être affiché dans le terminal à chaque déplacement.

1.2. Exigences Techniques

Le projet doit respecter un cahier des charges précis :

* Langage : Le projet doit être écrit en C et se conformer à la Norme de 42.
* Compilation : Un Makefile est requis, incluant les règles $(NAME), all, clean, fclean, et re, et compilant avec les options -Wall -Wextra -Werror.
* Gestion de la Mémoire : Aucune fuite de mémoire n'est tolérée. Toute la mémoire allouée sur le tas doit être correctement libérée.
* Argument : Le programme doit prendre en unique argument le chemin vers un fichier de carte ayant l'extension .ber.


--------------------------------------------------------------------------------


2. La Librairie MiniLibX (MLX)

La MiniLibX est une bibliothèque graphique simplifiée, conçue pour les étudiants. Elle sert d'API (Application Programming Interface) pour le système X-Window, qui est le système de fenêtrage standard sur les systèmes d'exploitation de type Unix.

2.1. Rôle et Architecture

La MLX est une surcouche de la bibliothèque Xlib. Elle masque la complexité de la communication directe avec le serveur X, qui agit comme un intermédiaire entre les périphériques d'entrée (clavier, souris) et les applications graphiques.

* Initialisation (mlx_init) : Cette fonction établit la connexion avec le serveur X. En réalité, elle alloue (malloc) une structure de contrôle (t_xvar) qui contient, entre autres, un pointeur vers une structure Display. Cette structure Display est la clé de la connexion et doit être libérée proprement.
* Nettoyage (mlx_destroy_display) : Cette fonction est un wrapper pour XCloseDisplay de la Xlib. Elle ferme la connexion au serveur X et libère les ressources associées à la structure Display.

2.2. Fonctions Clés et Cycle de Vie

Fonction	Rôle	Notes Cruciales
mlx_init()	Établit la connexion avec le serveur graphique.	Alloue de la mémoire qui doit être libérée. Retourne NULL en cas d'échec.
mlx_new_window()	Crée et affiche une nouvelle fenêtre.	Alloue de la mémoire pour la fenêtre. Doit être détruite avec mlx_destroy_window().
mlx_xpm_file_to_image()	Charge un fichier image (.xpm) en mémoire.	Alloue de la mémoire pour l'image. Doit être détruite avec mlx_destroy_image().
mlx_put_image_to_window()	Affiche une image chargée dans une fenêtre spécifiée.	C'est la méthode de rendu principale et la plus performante.
mlx_loop()	Démarre la boucle d'événements.	C'est une boucle infinie qui attend les événements (clavier, souris, etc.). Le code placé après cette fonction ne sera pas atteint tant que le programme est en cours.
mlx_key_hook() / mlx_hook()	Associe une fonction (un "hook") à un événement.	Permet de rendre le programme interactif en réagissant aux actions de l'utilisateur.
mlx_string_put()	Affiche une chaîne de caractères dans la fenêtre.	Utile pour le bonus qui consiste à afficher le compteur de mouvements à l'écran.

2.3. Gestion de la Mémoire

Une gestion rigoureuse de la mémoire est impérative pour éviter les fuites.

* Le pointeur retourné par mlx_init() est alloué et doit être libéré (free) après avoir détruit l'affichage.
* Chaque appel à mlx_new_window() doit être associé à un appel à mlx_destroy_window().
* Chaque image chargée avec mlx_xpm_file_to_image() doit être détruite avec mlx_destroy_image().
* Il est recommandé de créer une fonction de sortie centralisée (exit_game ou free_all) qui gère la libération de toutes les ressources dans l'ordre inverse de leur allocation.


--------------------------------------------------------------------------------


3. Parsing et Validation de la Carte

La validation de la carte est une étape critique qui doit avoir lieu avant même l'initialisation de la fenêtre graphique. Si une seule règle n'est pas respectée, le programme doit quitter proprement en affichant "Error\n" suivi d'un message explicite.

3.1. Règles de Validation Stricte

1. Format : La carte doit être un fichier avec l'extension .ber.
2. Forme : La carte doit être rectangulaire (toutes les lignes doivent avoir la même longueur).
3. Contenu : La carte ne peut contenir que les 5 caractères suivants : 0 (espace vide), 1 (mur), C (collectible), E (sortie), P (position de départ du joueur).
4. Composition :
  * Il doit y avoir exactement une position de départ (P).
  * Il doit y avoir exactement une sortie (E).
  * Il doit y avoir au moins un collectible (C).
5. Fermeture : La carte doit être entièrement entourée de murs (1). Les première et dernière lignes, ainsi que les première et dernière colonnes de chaque ligne, doivent être des murs.

3.2. Validation du Chemin (Pathfinding)

Le programme doit vérifier qu'il existe un chemin valide permettant au joueur d'atteindre tous les collectibles et la sortie. Cette vérification est non-triviale et nécessite un algorithme de parcours.

* Algorithme Recommandé : Flood Fill (Remplissage par diffusion)
  1. Créer une copie de la carte pour ne pas modifier l'originale.
  2. Localiser la position de départ du joueur (P).
  3. Lancer une fonction récursive (le "flood fill") depuis cette position.
  4. Cette fonction "peint" la case actuelle avec un caractère de visite (ex: 'V') et se propage récursivement aux quatre cases voisines (haut, bas, gauche, droite).
  5. La propagation s'arrête si la case est un mur (1) ou si elle a déjà été visitée ('V').
  6. Après l'exécution de l'algorithme, parcourir la carte copiée : si un collectible (C) ou la sortie (E) n'a pas été "peint" (visité), cela signifie qu'il est inaccessible et la carte est donc invalide.
* Alternative : Backtracking Une autre méthode consiste à utiliser un algorithme de backtracking depuis la sortie vers le départ, et depuis chaque collectible vers le départ. Si un seul de ces chemins n'aboutit pas, la carte est invalide.


--------------------------------------------------------------------------------


4. Rendu Graphique et Logique de Jeu

4.1. Le Cycle de Rendu (Game Loop)

Un jeu ne s'exécute pas de manière linéaire ; il fonctionne en boucle. La fonction mlx_loop() gère cette boucle. À chaque "tour de boucle" (ou frame), le jeu met à jour son état et redessine l'écran.

* Principe des Calques : Pour un rendu propre en 2D, il est conseillé de dessiner les éléments par couches successives à chaque frame :
  1. Arrière-plan : Dessiner un fond uniforme (le "sol").
  2. Carte statique : Dessiner les murs, les collectibles et la sortie.
  3. Éléments dynamiques : Dessiner le joueur à sa position actuelle.
* Importance du Rafraîchissement : Il est crucial de redessiner l'intégralité de la scène à chaque frame, y compris l'arrière-plan. Si l'arrière-plan n'est pas redessiné, les anciennes positions du joueur resteront visibles, créant un effet de "traînée" ou de "multiplication".

4.2. Optimisation du Rendu : Images vs Pixels

La fonction mlx_pixel_put() est extrêmement lente car elle envoie chaque pixel individuellement au serveur graphique. La méthode performante consiste à utiliser des images comme des tampons (buffers).

1. Créer une Image Buffer : Utiliser mlx_new_image() pour créer une image en mémoire de la taille de la fenêtre.
2. Obtenir l'Adresse des Pixels : Utiliser mlx_get_data_addr() pour obtenir un pointeur vers le premier pixel de cette image, ainsi que des informations sur son organisation en mémoire (bits par pixel, taille de ligne).
3. Dessiner dans le Buffer : Créer une fonction personnalisée (my_pixel_put) qui modifie directement les octets de ce buffer pour y "dessiner" les pixels. Le calcul de l'offset pour un pixel (x, y) est offset = (y * line_length) + (x * (bits_per_pixel / 8)).
4. Afficher l'Image Complète : Une fois l'image entière dessinée dans le buffer, l'afficher en une seule fois dans la fenêtre avec mlx_put_image_to_window(). Cette approche est nettement plus rapide et évite les scintillements.

4.3. Gestion des Événements et Déplacements

L'interaction se fait via les "hooks" de la MLX.

* mlx_key_hook : Permet d'intercepter les pressions de touches. Une fonction de gestion est associée à ce hook.
  * Cette fonction reçoit un keycode (le code de la touche pressée).
  * Si le keycode correspond à une touche de déplacement (W, A, S, D), elle vérifie si la case cible n'est pas un mur.
  * Si le déplacement est valide, les coordonnées (x, y) du joueur sont mises à jour, le compteur de mouvements est incrémenté et affiché.
  * Si le keycode est ESC, la fonction de nettoyage et de sortie du programme est appelée.
* mlx_hook avec l'événement DestroyNotify (17) : Permet de gérer la fermeture de la fenêtre via la croix rouge. La fonction associée doit également appeler la routine de sortie propre.


--------------------------------------------------------------------------------


5. Fonctionnalités Bonus

Le sujet propose des extensions pour les plus avancés, à n'implémenter que si la partie obligatoire est parfaite.

* Ennemis : Ajouter des patrouilles ennemies qui font perdre le joueur en cas de contact.
* Animation de Sprites : Animer le personnage du joueur ou les collectibles en alternant entre plusieurs images (sprites) à chaque frame ou à chaque déplacement.
* Compteur à l'Écran : Afficher le nombre de mouvements directement dans la fenêtre du jeu en utilisant mlx_string_put() au lieu du terminal.
